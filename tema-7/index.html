<!doctype html>
<html>
	<head>

		<title>Tema 8</title>
		<link rel="shortcut icon" href="images/favicon.ico" />

		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/white.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<img src="images/comillas-logo.png" width="50%" />
					<p>
						Programación de Aplicaciones Telemáticas
					</p>
				</section>
				<section>
					<h2>Tema 7: Testing en una aplicación</h2>
				</section>
				<section>
					<section>
						<h2>Agenda</h2>
						<h3>Sessión 1</h3>
						<ul>
							<li>Introducción</li>
							<li>Test funcionales</li>
							<li>Test no funcionales</li>
							<li>Piramide de testing</li>
							<li>Tests unitarios</li>
							<!-- <li>Test Doubles</li> -->
							<li>Consideracion de diseño de Tests</li>
							<li>Librerias</li>
							<!--
							<li>JUnit</li>
							<li>Mockito</li>
							-->

						</ul>
					</section>
					<section>
						<h2>Agenda</h2>
						<h3>Sessión 2</h3>
						<ul>
							<li>TDD</li>
							<li>Test End-to-End</li>
							<!--
							<li>Wiremock</li>
							<li>TestContainers</li>
							-->
						</ul>
					</section>
					<!--
					<section>
						<h2>Agenda</h2>
						<h3>Sessión 3</h3>
						<ul>
							<li>Java Microbenchmark Harness</li>
							<li>JMeter</li>
						</ul>
					</section>
					-->
				</section>
				<section>
					<h2>Sessión 1</h2>
				</section>
				<section>
					<section>
						<h2>Introdución</h2>
						<h3>¿Por que necesitas tests?</h3>
						<p>
							Es necesario verificar que el software cumple con las expectativas / requerimientos.
						</p>
						<img src="images/software-development-cycle.jpg" width="30%"/>
					</section>
				</section>
				<!--
				White box testing
				Black box testing
				-->
				<section>
					<section>
						<h2>Test funcionales</h2>
						<p>
							Una prueba funcional es una prueba basada en la ejecución,
							revisión y retroalimentación de las funcionalidades previamente diseñadas para
							el software.
						</p>
					</section>
					<section>
						<h2>Test funcionales</h2>
						<ul>
							<li>Configuracion del Build System</li>
							<li>Unit Tests</li>
							<li>Integration Tests</li>
							<li>Code Coverage</li>
							<!-- <li>Mutation Tests Coverage</li>
							<li>Reglas de Arquitectura</li> -->
							<li>Documentación</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>Test no funcionales</h2>
						<p>
							Una prueba no funcional es una prueba que evalua la forma en la que un desarrollo y/o aplicativo opera, haciendo foco en sus atributos y calidad. La calidad depende principalmente del tiempo, la precisión, la estabilidad, la corrección y la durabilidad de un producto en diversas circunstancias adversas.
						</p>
					</section>
					<section>
						<h2>Test no funcionales</h2>
						<ul>
							<li>Performance Testing</li>
							<li>Profiling Testing</li>
							<li>Security Testing</li>
						</ul>
					</section>
					<section>
						<h2>Test no funcionales</h2>
						<h3>Performance Testing</h3>
						<p>
							Las pruebas de rendimiento consisten en evaluar el comportamiento de un sistema en términos de capacidad de respuesta y estabilidad con una carga de trabajo determinada.
						</p>
					</section>
					<section>
						<h2>Test no funcionales</h2>
						<h3>Profiling Testing</h3>
						<p>
							En ingeniería de software, el perfilado ("perfilado de programas", "perfilado de software") es una forma de análisis dinámico de programas que mide, por ejemplo, el espacio (memoria) o la complejidad temporal de un programa, el uso de determinadas instrucciones o la frecuencia y duración de las llamadas a funciones.
						</p>
					</section>
					<section>
						<h2>Test no funcionales</h2>
						<h3>Security Testing</h3>
						<p>
							Las pruebas de seguridad son un proceso destinado a revelar fallos en los mecanismos de seguridad de un sistema de información que protegen los datos y mantienen la funcionalidad prevista
						</p>
					</section>
				</section>
				<section>
					<section>
						<h2>Pirámide de Testing</h2>
						<p>
							La pirámide de pruebas es una forma de pensar en cómo se deben utilizar los distintos tipos de pruebas automatizadas para crear un portfolio equilibrado. 
						</p>
						<img src="images/test-pyramid.png" />
					</section>
					<section>
						<h2>Pirámide de Testing</h2>
						<ul>
							<li>Unit Tests</li>
							<li>Integration Tests</li>
							<li>E2E Tests</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>Tests unitarios</h2>
						<p>
							Las pruebas unitarias aseguran de que una determinada unidad del código base funciona según lo previsto.
						</p>
						<img src="images/unit-tests.png" width="40%" />
					</section>
				</section>
				<!--
				<section>
					<section>
						<h2>Test Doubles</h2>
						<p>
							The term Test Double as the generic term for any kind of pretend object used
							in place of a real object for testing purposes.
						</p>
					</section>
					<section>
						<h2>Test Doubles</h2>
						<ul>
							<li>Mocks are what we are talking about here: objects pre-programmed with expectations which form a specification of the calls they are expected to receive.</li>
							<li>Stubs provide canned answers to calls made during the test, usually not responding at all to anything outside what's programmed in for the test.</li>
							<li>Spies are stubs that also record some information based on how they were called.</li>
						</ul>
					</section>
					<section>
						<h2>Test Doubles</h2>
						<ul>
							<li>Fake objects actually have working implementations, but usually take some shortcut.
								(an in memory database is a good example).</li>
							<li>Dummy objects are passed around but never actually used. </li>
						</ul>
					</section>
				</section>
				-->

				<section>
					<section>
						<h2>Consideracion de diseño de Tests</h2>
						<h3>Principios FIRST</h3>
						<ul>
							<li>Fast</li>
							<li>Independent</li>
							<li>Repeatable</li>
							<li>Self-validating</li>
							<li>Timely</li>
						</ul>
					</section>
					<section>
						<h2>Consideracion de diseño de Tests</h2>
						<h3>The Right BICEP</h3>
						<ul>
							<li>B – Todas las condiciones de contorno (Boundary) son correctas</li>
							<li>I – Puedes comprobar relaciones inversas (inverse)</li>
							<li>C – Puedes comprobar los resultados (check) con otros medios</li>
							<li>E – Puedes generar condiciones de error (error)</li>
							<li>P – Se pueden validar pruebas de rendimiento (performance)</li>
						</ul>
					</section>
				</section>
				<section>
					<section>
						<h2>JUnit</h2>
						<img src="images/junit-logo.png" />
						<p>
							JUnit es un marco de pruebas unitarias para el lenguaje de programación Java.
							Desempeña un papel crucial en el desarrollo basado en pruebas, y es una familia de marcos de pruebas unitarias conocidos colectivamente como xUnit
						</p>
					</section>
					<section>
						<h2>JUnit</h2>
						<p>
							JUnit promueve la idea de "first testing then coding",
							que hace hincapié en la creación de los datos de prueba para una pieza de código que
							puede ser probado primero y luego implementado.
							Este enfoque es como "prueba un poco, codifica un poco, prueba un poco, codifica un poco".
						</p>
					</section>
					<section>
						<h2>JUnit</h2>
						<h3>Features</h3>
						<ul>
							<li>Proporciona anotaciones para identificar los métodos de ensayo</li>
							<li>Proporciona afirmaciones para comprobar los resultados esperados</li>
							<li>Proporciona ejecutores de pruebas para ejecutar pruebas</li>
						</ul>
					</section>
					<section>
						<h2>JUnit</h2>
						<h3>Features</h3>
						<ul>
							<li>Permite codificar más rápido, lo que aumenta la calidad</li>
							<li>Elegantemente sencillo</li>
							<li>Pueden ejecutarse automáticamente y comprueban sus propios resultados y proporcionan información inmediata</li>
							<li>Las pruebas pueden organizarse en conjuntos de pruebas</li>
						</ul>
					</section>
					<section>
						<h2>JUnit</h2>
						<h3>Example</h3>
						<pre><code data-trim>
public class MyUnit {

    public String concatenate(String one, String two){
        return one + two;
    }
}
						</code></pre>
					</section>
					<section>
						<h2>JUnit</h2>
						<h3>Example</h3>
						<pre><code data-trim>
public class MyUnitTest {

    @Test
    public void given_MyUnit_when_concatenate_then_Ok() {
        MyUnit myUnit = new MyUnit();

        String result = myUnit.concatenate("one", "two");

        assertEquals("onetwo", result);

    }
}
						</code></pre>
					</section>
					<section>
						<h2>JUnit</h2>
						<h3>Example 2</h3>
						<p>Requirements:</p>
						<pre><code data-trim>
Write a program that prints the numbers from 1 to 100.
But for multiples of three print “Fizz” instead of
the number and for the multiples of five print “Buzz”.
For numbers which are multiples
of both three and five print “FizzBuzz”.
						</code></pre>
					</section>
					<section>
						<h2>JUnit</h2>
						<h3>Example 2</h3>
						<p>Requirements:</p>
						<pre><code data-trim>
public class FizzBuzzConverter {
    public String convert(int toConvertToFizzBuzz) {
        if(toConvertToFizzBuzz % 15 == 0) {
            return "FizzBuzz";
        }
        if(toConvertToFizzBuzz % 5 == 0) {
            return "Buzz";
        }
        if(toConvertToFizzBuzz % 3 == 0) {
            return "Fizz";
        }
        return String.valueOf(toConvertToFizzBuzz);
    }
}
						</code></pre>
					</section>
				</section>
				<!--
				<section>
					<section>
						<h2>Mockito</h2>
						<img src="images/mockito-logo.png" />
						<p>
							Mockito is a mocking framework, JAVA-based library that is used for
							effective unit testing of JAVA applications.
							Mockito is used to mock interfaces so that a dummy functionality
							can be added to a mock interface that can be used in unit testing.
						</p>
					</section>
					<section>
						<h2>Mockito</h2>
						<h3>Features</h3>
						<ul>
							<li>Mockito allows to write test methods compatible with "arrange/act/assert" approach.</li>
							<li>Mockito can be used to write Behavior Driven Development (BDD)-style.</li>
							<li>Mockito provides a nice, easily readable syntax. </li>
							<li>It is easy to read Mockito's error messages. </li>
						</ul>
					</section>
					<section>
						<h2>Mockito</h2>
						<h3>Example</h3>
						<pre><code data-trim>
public class WeatherForecast {
    private WeatherService globalWeather; [1]
    private WeatherService localService; [1]

    public WeatherForecast(WeatherService globalWeather, WeatherService localService) {
        this.localService = localService;
        this.globalWeather = globalWeather;
    }

    public Weather getForecast(String city) { [2]
        if (localService.hasForecastFor(city)) {
            return localService.getWeather(city);
        }
        return globalWeather.getWeather(city);
    }
}
						</code></pre>
					</section>
					<section>
						<h2>Mockito</h2>
						<h3>Example</h3>
						<pre><code data-trim>
@Test
public void shouldFetchWeatherForecastFromGlobalServiceIfNotAvailableLocally() {
	//Given
	WeatherService localWeatherService = Mockito.mock(WeatherService.class);
	WeatherService globalWeatherService = Mockito.mock(WeatherService.class);

	//When
	WeatherForecast forecast = new WeatherForecast(globalWeatherService, localWeatherService);
	Mockito.when(localWeatherService.hasForecastFor(anyString()))
	.thenReturn(false);
	Weather forecastedWeather = new Weather();
	Mockito.when(globalWeatherService.getWeather(anyString()))
	.thenReturn(forecastedWeather);

	//Then
	Weather weather = forecast.getForecast("myCity");
	assertThat(weather).isNotNull();
	assertThat(weather).isSameAs(forecastedWeather);
}
						</code></pre>
					</section>
				</section>
				-->
				<section>
					<h2>Referencias</h2>
					<ul>
						<li>https://es.wikipedia.org/wiki/Pruebas_de_software</li>
						<li>https://es.wikipedia.org/wiki/Pruebas_funcionales</li>
						<li>https://martinfowler.com/bliki/TestPyramid.html</li>
						<li>https://martinfowler.com/bliki/UnitTest.html</li>
						<li>https://martinfowler.com/testing/</li>
						<li>https://martinfowler.com/articles/practical-test-pyramid.html</li>
						<li>https://xp123.com/articles/3a-arrange-act-assert/</li>
						<li>https://martinfowler.com/bliki/GivenWhenThen.html</li>
						<li>https://martinfowler.com/bliki/TestDouble.html</li>
					</ul>
				</section>
				<section>
					<h2>Referencias</h2>
					<ul>
						<li>https://junit.org/junit5/</li>
						<!-- <li>https://site.mockito.org/</li> -->
					</ul>
				</section>
				<section>
					<h2>Referencias</h2>
					<ul>
						<li>https://spring.io/guides/gs/testing-web/</li>
					</ul>
				</section>

				<section>
					<h2>Sessión 2</h2>
				</section>
				<section>
					<h2>TDD</h2>
					<img src="images/tdd.png" />
				</section>
				<section>
					<!--
					<section>
						<h2>Test de integración</h2>
						<p>
							Integration testing (sometimes called integration and testing, abbreviated I&T)
							is the phase in software testing in which individual software modules are combined
							and tested as a group.
						</p>
					</section>
					-->
					<section>
						<h2>Test End-to-End</h2>
						<p>
						Las pruebas de extremo a extremo (End-to-End) son una técnica que comprueba todo el producto de software de principio a fin para garantizar que el flujo de la aplicación se comporta como se espera.
						</p>
					</section>
					<section>
						<h2>Test End-to-End</h2>
						<img src="images/scc1.png" />
					</section>
					<!--
					<section>
						<h2>Test de integración</h2>
						<img src="images/scc2.png" />
					</section>
					<section>
						<h2>Test de integración</h2>
						<img src="images/scc3.png" />
					</section>
					-->
				</section>
				<!--
				<section>
					<section>
						<h2>Wiremock</h2>
						<p>
							WireMock is a simulator for HTTP-based APIs.
							Some might consider it a service virtualization tool or a mock server.
						</p>
					</section>
					<section>
						<h2>Wiremock</h2>
						<h3>Example</h3>
						<pre><code data-trim>
@Test
public void exampleTest() {
    stubFor(get(urlEqualTo("/my/resource"))
            .withHeader("Accept", equalTo("text/xml"))
            .willReturn(aResponse()
                .withStatus(200)
                .withHeader("Content-Type", "text/xml")
                .withBody("<response>Some content</response>")));

    Result result = myHttpServiceCallingObject.doSomething();

    assertTrue(result.wasSuccessful());

    verify(postRequestedFor(urlMatching("/my/resource/[a-z0-9]+"))
            .withRequestBody(matching(".*<message>1234</message>.*"))
            .withHeader("Content-Type", notMatching("application/json")));
}
						</code></pre>
					</section>
				</section>
				-->
				<!--
				<section>
					<section>
						<h2>Testcontainers</h2>
						<p>
							Testcontainers is a Java library that supports JUnit tests, providing lightweight,
							throwaway instances of that can run in a Docker container.
						</p>
					</section>
					<section>
						<h2>Testcontainers</h2>
						<h3>Example</h3>
						<pre><code data-trim>
@Testcontainers
class MixedLifecycleTests {
	@Container
	private static final MySQLContainer MY_SQL_CONTAINER = new MySQLContainer();
	@Container
	private PostgreSQLContainer postgresqlContainer = new PostgreSQLContainer()
		.withDatabaseName("foo")
		.withUsername("foo")
		.withPassword("secret");
	@Test
	void test() {
		assertTrue(MY_SQL_CONTAINER.isRunning());
		assertTrue(postgresqlContainer.isRunning());
	}
}
						</code></pre>
					</section>
				</section>
-->
				<section>
					<h2>Referencias</h2>
					<ul>
						<li>https://martinfowler.com/bliki/IntegrationTest.html</li>
						<li>https://martinfowler.com/articles/mocksArentStubs.html</li>
						<li>https://martinfowler.com/bliki/TestDouble.html</li>
						<li>http://wiremock.org/</li>
						<li>https://www.testcontainers.org/</li>
					</ul>
				</section>
				<!--
				<section>
					<h2>Sessión 3</h2>
				</section>
				<section>
					<section>
						<h2>Java Microbenchmark Harness</h2>
						<p>
							JMH is a Java harness for building, running, and analysing nano/micro/milli/macro benchmarks
							written in Java and other languages targeting the JVM.
						</p>
					</section>
					<section>
						<h2>Java Microbenchmark Harness</h2>
						<h3>Example</h3>
						<pre><code data-trim>
public class JMHSample_01_HelloWorld {
    @Benchmark
    public void wellHelloThere() {
        // this method was intentionally left blank.
    }
    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(JMHSample_01_HelloWorld.class.getSimpleName())
                .forks(1)
                .build();

        new Runner(opt).run();
    }
}
						</code></pre>
					</section>
				</section>
				<section>
					<section>
						<h2>JMeter</h2>
						<img src="images/jmeter-logo.png" />
						<p>
							The Apache JMeter application is open source software,
							a 100% pure Java application designed to load test functional behavior
							and measure performance.
						</p>
					</section>
					<section>
						<h2>JMeter</h2>
						<img src="images/jmeter-screen.png" />
					</section>
				</section>

				<section>
					<h2>Referencias</h2>
					<ul>
						<li>https://openjdk.java.net/projects/code-tools/jmh/</li>
						<li>https://github.com/openjdk/jmh</li>
						<li>https://github.com/openjdk/jmh/tree/master/jmh-samples/src/main/java/org/openjdk/jmh/samples</li>
						<li>https://jmh.morethan.io/</li>
						<li>https://jmeter.apache.org/</li>
					</ul>
				</section>
				-->
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
			Reveal.configure(
				{ showNotes: true },
				{ showNotes: 'separate-page' },
				{ pdfMaxPagesPerSlide: 1 }
			);
		</script>
	</body>
</html>
